data_fetching_instruments.py:

import pandas as pd
from datetime import datetime

import requests

from utils import VALID_INTERVALS, logger
from indicators import detect_order_blocks, detect_fvgs, detect_support_resistance_levels, detect_breaker_blocks
from IndicatorUtils.indicators import Indicators

def fetch_ohlc_data(symbol: str, limit: int, interval: str):
    """
    Fetch historical OHLCV data for a given crypto pair, time period, and interval.
    """
    url = "https://api.bybit.com/v5/market/kline"
    params = {
        "category": "spot",
        "symbol": symbol.upper(),
        "interval": VALID_INTERVALS.get(interval, "60"),  # Default to 1h
        "limit": limit  # Number of candles to fetch
    }
    
    try:
        response = requests.get(url, params=params, timeout=10)
        logger.info(f"Response Status: {response.status_code}")
        logger.info(f"Response Content: {response.text}")
        
        if response.status_code != 200:
            logger.error(f"Non-200 response from API: {response.status_code}")
            return None
        
        data = response.json()
        
        if data.get("retCode") != 0:
            logger.error(f"API returned error: {data}")
            return None
        
        kline_data = data.get("result", {}).get("list", [])
        if not kline_data:
            logger.error("Empty kline_data from Bybit API.")
            return None
        
        dates, opens, highs, lows, closes, volumes = [], [], [], [], [], []
        
        for entry in kline_data[::-1]:
            ts_millis = int(entry[0])
            open_price = float(entry[1])
            high_price = float(entry[2])
            low_price = float(entry[3])
            close_price = float(entry[4])
            volume = float(entry[5])
            
            dt = datetime.utcfromtimestamp(ts_millis / 1000)
            
            dates.append(dt)
            opens.append(open_price)
            highs.append(high_price)
            lows.append(low_price)
            closes.append(close_price)
            volumes.append(volume)
        
        df = pd.DataFrame({
            'Open': opens,
            'High': highs,
            'Low': lows,
            'Close': closes,
            'Volume': volumes
        }, index=pd.DatetimeIndex(dates))
        
        return df
    
    except Exception as e:
        logger.error(f"Error while fetching data: {e}")
        return None
    
def analyze_data(df: pd.DataFrame, liq_lev_tolerance: float):
    indicators = Indicators()
    order_blocks = detect_order_blocks(df)
    fvgs = detect_fvgs(df)

    if not liq_lev_tolerance:
        liq_lev_tolerance = 0.02

    liquidity_levels = detect_support_resistance_levels(df, window=len(df), tolerance=liq_lev_tolerance)

    breaker_blocks = detect_breaker_blocks(df, liquidity_levels)

    logger.info(f"Detected Order Blocks: {order_blocks}")
    logger.info(f"Detected FVGs: {fvgs}")
    logger.info(f"Detected Liquidity Levels: {liquidity_levels}")
    logger.info(f"Detected Breaker Blocks: {breaker_blocks}")

    indicators.order_blocks = order_blocks
    indicators.fvgs = fvgs
    indicators.liquidity_levels = liquidity_levels
    indicators.breaker_blocks = breaker_blocks

    return indicators



message_handlers.py:

from telegram import InlineKeyboardMarkup, InlineKeyboardButton

from utils import user_selected_indicators

def get_indicator_selection_keyboard(user_id):
    """
    Create an inline keyboard for selecting indicators with a checkmark for selected ones.
    """
    selected = user_selected_indicators.get(user_id, {
        "order_blocks": False,
        "fvgs": False,
        "liquidity_levels": False,
        "breaker_blocks": False,
    })

    # Add a checkmark if the indicator is selected
    keyboard = [
        [
            InlineKeyboardButton(
                f"{'✔️ ' if selected['order_blocks'] else ''}Order Blocks", 
                callback_data="indicator_order_blocks"
            ),
            InlineKeyboardButton(
                f"{'✔️ ' if selected['fvgs'] else ''}FVGs", 
                callback_data="indicator_fvgs"
            ),
        ],
        [
            InlineKeyboardButton(
                f"{'✔️ ' if selected['liquidity_levels'] else ''}Liquidity Levels", 
                callback_data="indicator_liquidity_levels"
            ),
            InlineKeyboardButton(
                f"{'✔️ ' if selected['breaker_blocks'] else ''}Breaker Blocks", 
                callback_data="indicator_breaker_blocks"
            ),
        ],
        [InlineKeyboardButton("Done", callback_data="indicator_done")]
    ]
    return InlineKeyboardMarkup(keyboard)

async def handle_indicator_selection(update, _):
    """
    Handle the user's selection of indicators and update the inline keyboard dynamically.
    """
    query = update.callback_query
    await query.answer()

    # Get user ID and initialize preferences
    user_id = query.from_user.id
    if user_id not in user_selected_indicators:
        user_selected_indicators[user_id] = {
            "order_blocks": False,
            "fvgs": False,
            "liquidity_levels": False,
            "breaker_blocks": False,
        }

    # Update preferences based on selection
    data = query.data
    if data == "indicator_order_blocks":
        user_selected_indicators[user_id]["order_blocks"] = not user_selected_indicators[user_id]["order_blocks"]
    elif data == "indicator_fvgs":
        user_selected_indicators[user_id]["fvgs"] = not user_selected_indicators[user_id]["fvgs"]
    elif data == "indicator_liquidity_levels":
        user_selected_indicators[user_id]["liquidity_levels"] = not user_selected_indicators[user_id]["liquidity_levels"]
    elif data == "indicator_breaker_blocks":
        user_selected_indicators[user_id]["breaker_blocks"] = not user_selected_indicators[user_id]["breaker_blocks"]
    elif data == "indicator_done":
        selected = user_selected_indicators[user_id]
        await query.edit_message_text(
            f"You selected: {', '.join([key for key, val in selected.items() if val]) or 'None'}"
        )
        return

    # Update message with current selections and checkmarks
    await query.edit_message_reply_markup(
        reply_markup=get_indicator_selection_keyboard(user_id)
    )

async def select_indicators(update, _):
    """
    Start the process of selecting indicators.
    """
    user_id = update.effective_user.id
    user_selected_indicators[user_id] = {
        "order_blocks": False,
        "fvgs": False,
        "liquidity_levels": False,
        "breaker_blocks": False,
    }
    await update.message.reply_text(
        "Please choose the indicators you'd like to include:",
        reply_markup=get_indicator_selection_keyboard(user_id)
    )



plot_build_helpers.py:

import matplotlib.patches as mpatches
import matplotlib.lines as mlines

import mplfinance as mpf
import pandas as pd

from utils import logger

def plot_price_chart(df: pd.DataFrame, indicators):
    """
    Generate a candlestick chart with detected order blocks, FVGs, and support/resistance levels as horizontal lines.
    """

    fig, ax = mpf.plot(
        df,
        type='candle',
        style='yahoo',
        volume=True,
        returnfig=True,
        ylabel='Price (USDT)',
        ylabel_lower='Volume',
        tight_layout=True,
        figsize=(12, 8)
    )

    add_fvgs(ax, indicators.fvgs)
    add_order_blocks(ax, indicators.order_blocks, df)
    add_liquidity_levels(ax, indicators.liquidity_levels)
    add_breaker_blocks(ax, indicators.breaker_blocks)

    add_legend(ax, indicators)

    fig.subplots_adjust(left=0.05, right=0.95)
    fig.savefig('crypto_chart.png', bbox_inches='tight', pad_inches=0.1)

    return 'crypto_chart.png'

def add_legend(ax, indicators):
    handles = []
    if (indicators.order_blocks):
        handles.append(mlines.Line2D([], [], color='blue', marker='o', markersize=10, label='Bearish Order Block', linestyle='None'))
        handles.append(mlines.Line2D([], [], color='purple', marker='o', markersize=10, label='Bullish Order Block', linestyle='None'))

    if (indicators.fvgs):
        handles.append(mpatches.Patch(color='purple', alpha=0.3, label='FVG'))

    if (indicators.liquidity_levels):
        handles.append(mpatches.Patch(color='green', alpha=0.05, label='Bullish Breaker Block'))
        handles.append(mpatches.Patch(color='red', alpha=0.05, label='Bearish Breaker Block'))

    if (indicators.breaker_blocks):
        handles.append(mlines.Line2D([], [], color='red', linestyle='--', markersize=10, label='Resistance level'))
        handles.append(mlines.Line2D([], [], color='green', linestyle='--', markersize=10, label='Support level'))

    ax[0].legend(handles=handles, loc='upper left')

def add_order_blocks(ax, order_blocks, df):
    for block in order_blocks.list:
        idx = block.index
        low = block.low

        if idx < 0 or idx >= len(df):
            logger.warning(f"Invalid order block index: {idx}")
            continue

        circle_y_position = low * 0.995  # Slightly above the high for visibility

        ax[0].scatter(
            idx,
            circle_y_position,
            color='purple' if block.is_bullish() else 'blue',
            s=20,
            zorder=5,
            label="Order Block"
        )

def add_fvgs(ax, fvgs):
    for fvg in fvgs.list:
        start_idx = fvg.start_index
        end_idx = fvg.end_index
        start_price = fvg.start_price
        end_price = fvg.end_price

        if not fvg.covered:
            # Plot the FVG as a horizontal rectangle
            ax[0].fill_betweenx(
                y=[start_price, end_price],
                x1=start_idx,
                x2=end_idx,
                # color='blue' if start_price < end_price else 'orange',
                color='blue',
                alpha=0.2,
                label="FVG",
            )

def add_liquidity_levels(ax, liquidity_levels):
    for level in liquidity_levels.list:
        ax[0].axhline(
            y=level.price,
            color='green' if level.is_support() else 'red',
            linestyle='--',
            linewidth=1,
        )

def add_breaker_blocks(ax, breaker_blocks):
    for block in breaker_blocks.list:
        # Start time and end time (extend the block forward by 1-3 candles)
        start_index = block.index
        end_index = start_index + 2  # Add ~2 candles forward

        # Breaker block price range
        y1, y2 = block.zone

        # Choose color based on type
        color = 'green' if block.is_bullish() else 'red'

        # Fill between x-axis and y-axis values
        ax[0].fill_betweenx(
            y=[y1, y2],                     # Price range (y-axis)
            x1=start_index,                 # Start time of the block
            x2=end_index,                   # End time of the block
            color=color,
            alpha=0.05,
        )



indicators.py:

import pandas as pd

from IndicatorUtils.order_block_utils import OrderBlock, OrderBlocks
from IndicatorUtils.fvg_utils import FVG, FVGs
from IndicatorUtils.liquidity_level_utils import LiquidityLevel, LiquidityLevels
from IndicatorUtils.breaker_block_utils import BreakerBlock, BreakerBlocks

def detect_order_blocks(df: pd.DataFrame, volume_threshold=1.5, body_percentage=0.5, breakout_factor=1.01):
    """
    Detect less sensitive order blocks based on bullish or bearish breakouts.

    Parameters:
        df (pd.DataFrame): A DataFrame containing OHLCV data with columns ['Open', 'High', 'Low', 'Close', 'Volume'].
        volume_threshold (float): Multiplier to determine significant volume (e.g., 1.5x the average).
        body_percentage (float): Minimum body size as a percentage of the candle's range to be considered significant.
        breakout_factor (float): Multiplier to determine the strength of the breakout (e.g., 1.01 for 1% breakout).

    Returns:
        list: A list of tuples representing order blocks, where each tuple is:
              (index, high, low, type)
              - index: Index of the order block candle
              - high: High of the candle
              - low: Low of the candle
              - type: 'bullish' or 'bearish'
    """
    order_blocks = OrderBlocks()
    avg_volume = df['Volume'].mean()

    for i in range(1, len(df) - 3):
        high, low, close, open_price = df['High'][i], df['Low'][i], df['Close'][i], df['Open'][i]
        volume = df['Volume'][i]

        body_size = abs(close - open_price)
        range_size = high - low

        # Skip small candles
        if range_size == 0 or body_size / range_size < body_percentage:
            continue

        # Skip low-volume candles
        if volume < volume_threshold * avg_volume:
            continue

        # Detect order blocks
        if close < open_price and df['Close'][i + 1] > high * breakout_factor:
            order_blocks.add(OrderBlock('bearish', i, high, low))
        elif close > open_price and df['Close'][i + 1] < low * breakout_factor:
            order_blocks.add(OrderBlock('bullish', i, high, low))

    return order_blocks


def detect_fvgs(df: pd.DataFrame):
    """
    Detect Fair Value Gaps (FVGs) in price action and check if they are covered later.

    Parameters:
        df (pd.DataFrame): A DataFrame containing OHLCV data with columns ['Open', 'High', 'Low', 'Close'].

    Returns:
        list: A list of tuples representing FVGs, where each tuple is:
              (start_index, end_index, start_price, end_price, type, covered)
              - start_index: Start of the gap
              - end_index: End of the gap
              - start_price: Price at the start of the gap
              - end_price: Price at the end of the gap
              - type: 'bullish' or 'bearish'
              - covered: Boolean indicating whether the FVG was later covered
    """
    fvgs = FVGs()

    for i in range(2, len(df)):
        # Bullish FVG
        if df['Low'][i] > df['High'][i - 2]:
            is_covered = False
            for j in range(i + 1, len(df)):
                if df['Low'][j] <= df['Low'][i]:
                   is_covered = True 
                   break

            fvgs.add(FVG(i - 2, i, df['High'][i - 2], df['Low'][i], 'bullish', is_covered))

        # Bearish FVG
        elif df['High'][i] < df['Low'][i - 2]:
            is_covered = False
            for j in range(i + 1, len(df)):
                if df['High'][j] >= df['High'][i]:
                   is_covered = True 
                   break

            fvgs.add(FVG(i - 2, i, df['Low'][i - 2], df['High'][i], 'bearish', is_covered))

    return fvgs


### NOTE: Instead of support and resistance levels we can do just a liquidity levels

def detect_support_resistance_levels(df: pd.DataFrame, window: int = 50, tolerance: float = 0.05):
    """
    Identifies support and resistance levels within a given range of candlesticks.

    Parameters:
        df (pd.DataFrame): OHLC data (Open, High, Low, Close).
        window (int): The number of recent candlesticks to analyze (between 50 and 200).
        tolerance (float): The tolerance for grouping nearby levels (default is 0.2%).

    Returns:
        Tuple[List[float], List[float]]: Lists of support and resistance levels.
    """
    # Ensure the window size does not exceed the DataFrame size
    recent_df = df.tail(window)
    levels = LiquidityLevels()

    for i in range(1, len(recent_df) - 1):
        low, high = recent_df['Low'].iloc[i], recent_df['High'].iloc[i]

        # Local minima as support
        if low < recent_df['Low'].iloc[i - 1] and low < recent_df['Low'].iloc[i + 1]:
            levels.add(LiquidityLevel('support', low))

        # Local maxima as resistance
        if high > recent_df['High'].iloc[i - 1] and high > recent_df['High'].iloc[i + 1]:
            levels.add(LiquidityLevel('resistance', high))

    # Group levels
    grouped_levels = LiquidityLevels()
    for level in levels.list:
        if not grouped_levels or abs(level.price - grouped_levels.list[-1].price) > tolerance * level.price:
            grouped_levels.add(level)

    return grouped_levels

def detect_breaker_blocks(df: pd.DataFrame, liquidity_levels: LiquidityLevels):
    """
    Detect breaker blocks based on liquidity sweeps and reversals.

    Parameters:
        df (pd.DataFrame): OHLCV DataFrame with columns ['Open', 'High', 'Low', 'Close'].
        liquidity_levels (list): A list of LiquidityLevel objects (support/resistance).

    Returns:
        list: A list of BreakerBlock objects.
    """
    breaker_blocks = BreakerBlocks()

    # Iterate over each candle
    for i in range(2, len(df)):
        low, high, close = df['Low'].iloc[i], df['High'].iloc[i], df['Close'].iloc[i]

        # Check for bullish and bearish breaker blocks
        for level in liquidity_levels.list:
            # Bullish breaker: sweeps support and reverses upward
            if level.is_support() and low < level.price and close > level.price:
                breaker_blocks.add(BreakerBlock(
                    block_type='bullish',
                    index=i,
                    zone=(low, high)
                ))

            # Bearish breaker: sweeps resistance and reverses downward
            elif level.is_resistance() and high > level.price and close < level.price:
                breaker_blocks.add(BreakerBlock(
                    block_type='bearish',
                    index=i,
                    zone=(low, high)
                ))

    return breaker_blocks



chatGPT_script.py:

import os

def is_binary_file(file_path):
    """
    Check if a file is binary by reading its first few bytes.
    """
    try:
        with open(file_path, 'rb') as file:
            chunk = file.read(1024)  # Read the first 1024 bytes
        if b'\0' in chunk:  # Binary files usually contain null bytes
            return True
    except Exception as e:
        print(f"Error reading file {file_path}: {e}")
        return True
    return False

def save_files_content_to_text(directory, output_file):
    try:
        with open(output_file, 'w', encoding='utf-8') as output:
            for filename in os.listdir(directory):
                file_path = os.path.join(directory, filename)
                if os.path.isfile(file_path):
                    if is_binary_file(file_path):
                        print(f"Skipping binary file: {filename}")
                        continue
                    with open(file_path, 'r', encoding='utf-8') as file:
                        content = file.read()
                    output.write(f"{filename}:\n\n{content}\n\n\n")
        print(f"Content written to {output_file} successfully.")
    except Exception as e:
        print(f"An error occurred: {e}")

# Directory containing files
input_directory = "/Users/yaroslav/cryptoBot/"

# Output file
output_filename = "output.txt"

save_files_content_to_text(input_directory, output_filename)


README.md:

<img width="872" alt="image" src="https://github.com/user-attachments/assets/98c74f20-6201-48bc-8134-38e004c9f0d0" />

Todo:
- [x] Create the Breaker Block indicator
[Maybe other indicators will be useful]
- [x] **Easy**: Create every indicator output as classes
- [x] **Easy**: Create a possibility to return non-visual (numeric) data
- [ ] **Easy**: Add tests for this
- [x] **Easy**: Create a possibility to enable/disable indicators
- [ ] **Easy**: Add tests for this
- [ ] Create a logic to find predictable movements, based on the created indicators
- [ ] Add another tests for this
- [ ] Find the most appropriate time interval for predictions
- [ ] Consider about the timing of checking the market
- [ ] Consider about a logic of pinging users about predictable movements
- [ ] Add tests for this
- [ ] Create a neural network and make it learn on own data
- [ ] Integrate a neural network to the predictions system
  



bot.py:

import os
from dotenv import load_dotenv
import logging

# Telegram imports
from telegram import Update
from telegram.ext import CommandHandler, CallbackContext, ApplicationBuilder, CallbackQueryHandler

from utils import user_selected_indicators
from helpers import check_and_analyze
from plot_build_helpers import plot_price_chart
from message_handlers import select_indicators, handle_indicator_selection

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

load_dotenv()

async def send_crypto_chart(update: Update, context: CallbackContext):
    """
    Telegram handler to fetch OHLC data, analyze indicators, and send the chart back to the user.
    """
    chat_id = update.effective_chat.id
    user_id = update.effective_user.id

    # Analyze data
    (indicators, df) = await check_and_analyze(update, user_id, context)

    # Filter indicators based on user selection
    filtered_indicators = indicators.filter(user_selected_indicators[user_id])

    # Plot chart
    chart_path = plot_price_chart(df, filtered_indicators)
    if chart_path is None:
        await update.message.reply_text("Error generating the chart. Please try again.")
        return

    # Send the chart to the user
    with open(chart_path, 'rb') as f:
        await context.bot.send_photo(chat_id=chat_id, photo=f)
    
    df = df.reset_index(drop=True)

async def send_text_data(update: Update, context: CallbackContext):
    """
    Telegram handler to fetch OHLC data for a user-specified crypto pair, time period, interval, and liquidity level detection tolerance
    plot the candlestick chart, and send it back to the user.
    Usage: /text_result <symbol> <hours> <interval> <tolerance>, e.g. /text_result BTCUSDT 42 15m 0.03
    """
    user_id = update.effective_user.id

    # Analyze data
    (indicators, df) = await check_and_analyze(update, user_id, context)

    # Filter indicators based on user selection
    filtered_indicators = indicators.filter(user_selected_indicators[user_id])

    await update.message.reply_text(str(filtered_indicators))
    
    df = df.reset_index(drop=True)

if __name__ == "__main__":
    TOKEN = os.getenv('API_TELEGRAM_KEY')

    app = ApplicationBuilder().token(TOKEN).build()
    app.add_handler(CommandHandler("chart", send_crypto_chart))
    app.add_handler(CommandHandler("text_result", send_text_data))
    app.add_handler(CommandHandler("select_indicators", select_indicators))
    app.add_handler(CallbackQueryHandler(handle_indicator_selection))

    print("Bot is running...")
    app.run_polling()



.gitignore:

.env
crypto_chart.png



utils.py:

import logging

logger = logging.getLogger(__name__)

VALID_INTERVALS = {
    "1m": "1",  # 1 minute
    "5m": "5",  # 5 minutes
    "15m": "15",  # 15 minutes
    "30m": "30",  # 30 minutes
    "1h": "60",  # 1 hour
    "4h": "240",  # 4 hours
    "1d": "D",  # 1 day
    "1w": "W",  # 1 week
}

# Store user-selected indicators temporarily
user_selected_indicators = {}



.env:

API_TELEGRAM_KEY=7687130619:AAG9Ir0fbWVXUm2F6M0MYzGkMwZ1ME8aqPQ


helpers.py:

import pandas as pd

from data_fetching_instruments import fetch_ohlc_data, analyze_data
from utils import VALID_INTERVALS, user_selected_indicators

def calculate_macd(data: pd.DataFrame):
    """
    Calculate MACD and Signal Line.
    """
    short_ema = data['Close'].ewm(span=12, adjust=False).mean()
    long_ema = data['Close'].ewm(span=26, adjust=False).mean()
    macd = short_ema - long_ema
    signal = macd.ewm(span=9, adjust=False).mean()
    return macd, signal

def calculate_rsi(data: pd.DataFrame, period: int = 14):
    """
    Calculate Relative Strength Index (RSI).
    """
    delta = data['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

async def input_sanity_check(args, update) -> tuple:
    # Default values
    symbol = "BTCUSDT"
    hours = 24
    interval = "1h"
    liq_lev_tolerance=0

    if len(args) >= 1:
        symbol = args[0].upper()
    if len(args) >= 2:
        try:
            hours = int(args[1])
        except ValueError:
            await update.message.reply_text("Invalid hours specified. Please provide a valid number.")
            return tuple()
    if len(args) >= 3:
        interval = args[2].lower()
        if interval not in VALID_INTERVALS:
            await update.message.reply_text(f"Invalid interval specified. Valid intervals are: {', '.join(VALID_INTERVALS.keys())}")
            return tuple()
    if len(args) >= 4:
        liq_lev_tolerance = float(args[3])
        if liq_lev_tolerance < 0 or liq_lev_tolerance > 1:
            await update.message.reply_text(f"Invalid liquidity level tolerance specified. It should be a number between 0 and 1")
            return tuple()

    if hours < 1 or hours > 200:
        await update.message.reply_text("Amount of intervals must be between 1 and 200 (due to API limits).")
        return tuple()

    return (symbol, hours, interval, liq_lev_tolerance)

async def check_and_analyze(update, user_id, context):
    args = context.args

    res = await input_sanity_check(args, update)

    if (not res):
        return

    # Check if user selected indicators
    if user_id not in user_selected_indicators or not any(user_selected_indicators[user_id].values()):
        await update.message.reply_text("Please select indicators using /select_indicators before requesting a chart.")
        return

    symbol = res[0]
    hours = res[1]
    interval = res[2]
    liq_lev_tolerance = res[3]

    limit = min(hours, 200)
    await update.message.reply_text(f"Fetching {symbol} price data for the last {hours} periods with interval {interval}, please wait...")
    
    df = fetch_ohlc_data(symbol, limit, interval)
    if df is None or df.empty:
        await update.message.reply_text(f"Error fetching data for {symbol}. Please check the pair and try again.")
        return

    indicators = analyze_data(df, liq_lev_tolerance)
    return (indicators, df)



output.txt:

data_fetching_instruments.py:

import pandas as pd
from datetime import datetime

import requests

from utils import VALID_INTERVALS, logger
from indicators import detect_order_blocks, detect_fvgs, detect_support_resistance_levels, detect_breaker_blocks
from IndicatorUtils.indicators import Indicators

def fetch_ohlc_data(symbol: str, limit: int, interval: str):
    """
    Fetch historical OHLCV data for a given crypto pair, time period, and interval.
    """
    url = "https://api.bybit.com/v5/market/kline"
    params = {
        "category": "spot",
        "symbol": symbol.upper(),
        "interval": VALID_INTERVALS.get(interval, "60"),  # Default to 1h
        "limit": limit  # Number of candles to fetch
    }
    
    try:
        response = requests.get(url, params=params, timeout=10)
        logger.info(f"Response Status: {response.status_code}")
        logger.info(f"Response Content: {response.text}")
        
        if response.status_code != 200:
            logger.error(f"Non-200 response from API: {response.status_code}")
            return None
        
        data = response.json()
        
        if data.get("retCode") != 0:
            logger.error(f"API returned error: {data}")
            return None
        
        kline_data = data.get("result", {}).get("list", [])
        if not kline_data:
            logger.error("Empty kline_data from Bybit API.")
            return None
        
        dates, opens, highs, lows, closes, volumes = [], [], [], [], [], []
        
        for entry in kline_data[::-1]:
            ts_millis = int(entry[0])
            open_price = float(entry[1])
            high_price = float(entry[2])
            low_price = float(entry[3])
            close_price = float(entry[4])
            volume = float(entry[5])
            
            dt = datetime.utcfromtimestamp(ts_millis / 1000)
            
            dates.append(dt)
            opens.append(open_price)
            highs.append(high_price)
            lows.append(low_price)
            closes.append(close_price)
            volumes.append(volume)
        
        df = pd.DataFrame({
            'Open': opens,
            'High': highs,
            'Low': lows,
            'Close': closes,
            'Volume': volumes
        }, index=pd.DatetimeIndex(dates))
        
        return df
    
    except Exception as e:
        logger.error(f"Error while fetching data: {e}")
        return None
    
def analyze_data(df: pd.DataFrame, liq_lev_tolerance: float):
    indicators = Indicators()
    order_blocks = detect_order_blocks(df)
    fvgs = detect_fvgs(df)

    if not liq_lev_tolerance:
        liq_lev_tolerance = 0.02

    liquidity_levels = detect_support_resistance_levels(df, window=len(df), tolerance=liq_lev_tolerance)

    breaker_blocks = detect_breaker_blocks(df, liquidity_levels)

    logger.info(f"Detected Order Blocks: {order_blocks}")
    logger.info(f"Detected FVGs: {fvgs}")
    logger.info(f"Detected Liquidity Levels: {liquidity_levels}")
    logger.info(f"Detected Breaker Blocks: {breaker_blocks}")

    indicators.order_blocks = order_blocks
    indicators.fvgs = fvgs
    indicators.liquidity_levels = liquidity_levels
    indicators.breaker_blocks = breaker_blocks

    return indicators



message_handlers.py:

from telegram import InlineKeyboardMarkup, InlineKeyboardButton

from utils import user_selected_indicators

def get_indicator_selection_keyboard(user_id):
    """
    Create an inline keyboard for selecting indicators with a checkmark for selected ones.
    """
    selected = user_selected_indicators.get(user_id, {
        "order_blocks": False,
        "fvgs": False,
        "liquidity_levels": False,
        "breaker_blocks": False,
    })

    # Add a checkmark if the indicator is selected
    keyboard = [
        [
            InlineKeyboardButton(
                f"{'✔️ ' if selected['order_blocks'] else ''}Order Blocks", 
                callback_data="indicator_order_blocks"
            ),
            InlineKeyboardButton(
                f"{'✔️ ' if selected['fvgs'] else ''}FVGs", 
                callback_data="indicator_fvgs"
            ),
        ],
        [
            InlineKeyboardButton(
                f"{'✔️ ' if selected['liquidity_levels'] else ''}Liquidity Levels", 
                callback_data="indicator_liquidity_levels"
            ),
            InlineKeyboardButton(
                f"{'✔️ ' if selected['breaker_blocks'] else ''}Breaker Blocks", 
                callback_data="indicator_breaker_blocks"
            ),
        ],
        [InlineKeyboardButton("Done", callback_data="indicator_done")]
    ]
    return InlineKeyboardMarkup(keyboard)

async def handle_indicator_selection(update, _):
    """
    Handle the user's selection of indicators and update the inline keyboard dynamically.
    """
    query = update.callback_query
    await query.answer()

    # Get user ID and initialize preferences
    user_id = query.from_user.id
    if user_id not in user_selected_indicators:
        user_selected_indicators[user_id] = {
            "order_blocks": False,
            "fvgs": False,
            "liquidity_levels": False,
            "breaker_blocks": False,
        }

    # Update preferences based on selection
    data = query.data
    if data == "indicator_order_blocks":
        user_selected_indicators[user_id]["order_blocks"] = not user_selected_indicators[user_id]["order_blocks"]
    elif data == "indicator_fvgs":
        user_selected_indicators[user_id]["fvgs"] = not user_selected_indicators[user_id]["fvgs"]
    elif data == "indicator_liquidity_levels":
        user_selected_indicators[user_id]["liquidity_levels"] = not user_selected_indicators[user_id]["liquidity_levels"]
    elif data == "indicator_breaker_blocks":
        user_selected_indicators[user_id]["breaker_blocks"] = not user_selected_indicators[user_id]["breaker_blocks"]
    elif data == "indicator_done":
        selected = user_selected_indicators[user_id]
        await query.edit_message_text(
            f"You selected: {', '.join([key for key, val in selected.items() if val]) or 'None'}"
        )
        return

    # Update message with current selections and checkmarks
    await query.edit_message_reply_markup(
        reply_markup=get_indicator_selection_keyboard(user_id)
    )

async def select_indicators(update, _):
    """
    Start the process of selecting indicators.
    """
    user_id = update.effective_user.id
    user_selected_indicators[user_id] = {
        "order_blocks": False,
        "fvgs": False,
        "liquidity_levels": False,
        "breaker_blocks": False,
    }
    await update.message.reply_text(
        "Please choose the indicators you'd like to include:",
        reply_markup=get_indicator_selection_keyboard(user_id)
    )



plot_build_helpers.py:

import matplotlib.patches as mpatches
import matplotlib.lines as mlines

import mplfinance as mpf
import pandas as pd

from utils import logger

def plot_price_chart(df: pd.DataFrame, indicators):
    """
    Generate a candlestick chart with detected order blocks, FVGs, and support/resistance levels as horizontal lines.
    """

    fig, ax = mpf.plot(
        df,
        type='candle',
        style='yahoo',
        volume=True,
        returnfig=True,
        ylabel='Price (USDT)',
        ylabel_lower='Volume',
        tight_layout=True,
        figsize=(12, 8)
    )

    add_fvgs(ax, indicators.fvgs)
    add_order_blocks(ax, indicators.order_blocks, df)
    add_liquidity_levels(ax, indicators.liquidity_levels)
    add_breaker_blocks(ax, indicators.breaker_blocks)

    add_legend(ax, indicators)

    fig.subplots_adjust(left=0.05, right=0.95)
    fig.savefig('crypto_chart.png', bbox_inches='tight', pad_inches=0.1)

    return 'crypto_chart.png'

def add_legend(ax, indicators):
    handles = []
    if (indicators.order_blocks):
        handles.append(mlines.Line2D([], [], color='blue', marker='o', markersize=10, label='Bearish Order Block', linestyle='None'))
        handles.append(mlines.Line2D([], [], color='purple', marker='o', markersize=10, label='Bullish Order Block', linestyle='None'))

    if (indicators.fvgs):
        handles.append(mpatches.Patch(color='purple', alpha=0.3, label='FVG'))

    if (indicators.liquidity_levels):
        handles.append(mpatches.Patch(color='green', alpha=0.05, label='Bullish Breaker Block'))
        handles.append(mpatches.Patch(color='red', alpha=0.05, label='Bearish Breaker Block'))

    if (indicators.breaker_blocks):
        handles.append(mlines.Line2D([], [], color='red', linestyle='--', markersize=10, label='Resistance level'))
        handles.append(mlines.Line2D([], [], color='green', linestyle='--', markersize=10, label='Support level'))

    ax[0].legend(handles=handles, loc='upper left')

def add_order_blocks(ax, order_blocks, df):
    for block in order_blocks.list:
        idx = block.index
        low = block.low

        if idx < 0 or idx >= len(df):
            logger.warning(f"Invalid order block index: {idx}")
            continue

        circle_y_position = low * 0.995  # Slightly above the high for visibility

        ax[0].scatter(
            idx,
            circle_y_position,
            color='purple' if block.is_bullish() else 'blue',
            s=20,
            zorder=5,
            label="Order Block"
        )

def add_fvgs(ax, fvgs):
    for fvg in fvgs.list:
        start_idx = fvg.start_index
        end_idx = fvg.end_index
        start_price = fvg.start_price
        end_price = fvg.end_price

        if not fvg.covered:
            # Plot the FVG as a horizontal rectangle
            ax[0].fill_betweenx(
                y=[start_price, end_price],
                x1=start_idx,
                x2=end_idx,
                # color='blue' if start_price < end_price else 'orange',
                color='blue',
                alpha=0.2,
                label="FVG",
            )

def add_liquidity_levels(ax, liquidity_levels):
    for level in liquidity_levels.list:
        ax[0].axhline(
            y=level.price,
            color='green' if level.is_support() else 'red',
            linestyle='--',
            linewidth=1,
        )

def add_breaker_blocks(ax, breaker_blocks):
    for block in breaker_blocks.list:
        # Start time and end time (extend the block forward by 1-3 candles)
        start_index = block.index
        end_index = start_index + 2  # Add ~2 candles forward

        # Breaker block price range
        y1, y2 = block.zone

        # Choose color based on type
        color = 'green' if block.is_bullish() else 'red'

        # Fill between x-axis and y-axis values
        ax[0].fill_betweenx(
            y=[y1, y2],                     # Price range (y-axis)
            x1=start_index,                 # Start time of the block
            x2=end_index,                   # End time of the block
            color=color,
            alpha=0.05,
        )



indicators.py:

import pandas as pd

from IndicatorUtils.order_block_utils import OrderBlock, OrderBlocks
from IndicatorUtils.fvg_utils import FVG, FVGs
from IndicatorUtils.liquidity_level_utils import LiquidityLevel, LiquidityLevels
from IndicatorUtils.breaker_block_utils import BreakerBlock, BreakerBlocks

def detect_order_blocks(df: pd.DataFrame, volume_threshold=1.5, body_percentage=0.5, breakout_factor=1.01):
    """
    Detect less sensitive order blocks based on bullish or bearish breakouts.

    Parameters:
        df (pd.DataFrame): A DataFrame containing OHLCV data with columns ['Open', 'High', 'Low', 'Close', 'Volume'].
        volume_threshold (float): Multiplier to determine significant volume (e.g., 1.5x the average).
        body_percentage (float): Minimum body size as a percentage of the candle's range to be considered significant.
        breakout_factor (float): Multiplier to determine the strength of the breakout (e.g., 1.01 for 1% breakout).

    Returns:
        list: A list of tuples representing order blocks, where each tuple is:
              (index, high, low, type)
              - index: Index of the order block candle
              - high: High of the candle
              - low: Low of the candle
              - type: 'bullish' or 'bearish'
    """
    order_blocks = OrderBlocks()
    avg_volume = df['Volume'].mean()

    for i in range(1, len(df) - 3):
        high, low, close, open_price = df['High'][i], df['Low'][i], df['Close'][i], df['Open'][i]
        volume = df['Volume'][i]

        body_size = abs(close - open_price)
        range_size = high - low

        # Skip small candles
        if range_size == 0 or body_size / range_size < body_percentage:
            continue

        # Skip low-volume candles
        if volume < volume_threshold * avg_volume:
            continue

        # Detect order blocks
        if close < open_price and df['Close'][i + 1] > high * breakout_factor:
            order_blocks.add(OrderBlock('bearish', i, high, low))
        elif close > open_price and df['Close'][i + 1] < low * breakout_factor:
            order_blocks.add(OrderBlock('bullish', i, high, low))

    return order_blocks


def detect_fvgs(df: pd.DataFrame):
    """
    Detect Fair Value Gaps (FVGs) in price action and check if they are covered later.

    Parameters:
        df (pd.DataFrame): A DataFrame containing OHLCV data with columns ['Open', 'High', 'Low', 'Close'].

    Returns:
        list: A list of tuples representing FVGs, where each tuple is:
              (start_index, end_index, start_price, end_price, type, covered)
              - start_index: Start of the gap
              - end_index: End of the gap
              - start_price: Price at the start of the gap
              - end_price: Price at the end of the gap
              - type: 'bullish' or 'bearish'
              - covered: Boolean indicating whether the FVG was later covered
    """
    fvgs = FVGs()

    for i in range(2, len(df)):
        # Bullish FVG
        if df['Low'][i] > df['High'][i - 2]:
            is_covered = False
            for j in range(i + 1, len(df)):
                if df['Low'][j] <= df['Low'][i]:
                   is_covered = True 
                   break

            fvgs.add(FVG(i - 2, i, df['High'][i - 2], df['Low'][i], 'bullish', is_covered))

        # Bearish FVG
        elif df['High'][i] < df['Low'][i - 2]:
            is_covered = False
            for j in range(i + 1, len(df)):
                if df['High'][j] >= df['High'][i]:
                   is_covered = True 
                   break

            fvgs.add(FVG(i - 2, i, df['Low'][i - 2], df['High'][i], 'bearish', is_covered))

    return fvgs


### NOTE: Instead of support and resistance levels we can do just a liquidity levels

def detect_support_resistance_levels(df: pd.DataFrame, window: int = 50, tolerance: float = 0.05):
    """
    Identifies support and resistance levels within a given range of candlesticks.

    Parameters:
        df (pd.DataFrame): OHLC data (Open, High, Low, Close).
        window (int): The number of recent candlesticks to analyze (between 50 and 200).
        tolerance (float): The tolerance for grouping nearby levels (default is 0.2%).

    Returns:
        Tuple[List[float], List[float]]: Lists of support and resistance levels.
    """
    # Ensure the window size does not exceed the DataFrame size
    recent_df = df.tail(window)
    levels = LiquidityLevels()

    for i in range(1, len(recent_df) - 1):
        low, high = recent_df['Low'].iloc[i], recent_df['High'].iloc[i]

        # Local minima as support
        if low < recent_df['Low'].iloc[i - 1] and low < recent_df['Low'].iloc[i + 1]:
            levels.add(LiquidityLevel('support', low))

        # Local maxima as resistance
        if high > recent_df['High'].iloc[i - 1] and high > recent_df['High'].iloc[i + 1]:
            levels.add(LiquidityLevel('resistance', high))

    # Group levels
    grouped_levels = LiquidityLevels()
    for level in levels.list:
        if not grouped_levels or abs(level.price - grouped_levels.list[-1].price) > tolerance * level.price:
            grouped_levels.add(level)

    return grouped_levels

def detect_breaker_blocks(df: pd.DataFrame, liquidity_levels: LiquidityLevels):
    """
    Detect breaker blocks based on liquidity sweeps and reversals.

    Parameters:
        df (pd.DataFrame): OHLCV DataFrame with columns ['Open', 'High', 'Low', 'Close'].
        liquidity_levels (list): A list of LiquidityLevel objects (support/resistance).

    Returns:
        list: A list of BreakerBlock objects.
    """
    breaker_blocks = BreakerBlocks()

    # Iterate over each candle
    for i in range(2, len(df)):
        low, high, close = df['Low'].iloc[i], df['High'].iloc[i], df['Close'].iloc[i]

        # Check for bullish and bearish breaker blocks
        for level in liquidity_levels.list:
            # Bullish breaker: sweeps support and reverses upward
            if level.is_support() and low < level.price and close > level.price:
                breaker_blocks.add(BreakerBlock(
                    block_type='bullish',
                    index=i,
                    zone=(low, high)
                ))

            # Bearish breaker: sweeps resistance and reverses downward
            elif level.is_resistance() and high > level.price and close < level.price:
                breaker_blocks.add(BreakerBlock(
                    block_type='bearish',
                    index=i,
                    zone=(low, high)
                ))

    return breaker_blocks



chatGPT_script.py:

import os

def is_binary_file(file_path):
    """
    Check if a file is binary by reading its first few bytes.
    """
    try:
        with open(file_path, 'rb') as file:
            chunk = file.read(1024)  # Read the first 1024 bytes
        if b'\0' in chunk:  # Binary files usually contain null bytes
            return True
    except Exception as e:
        print(f"Error reading file {file_path}: {e}")
        return True
    return False

def save_files_content_to_text(directory, output_file):
    try:
        with open(output_file, 'w', encoding='utf-8') as output:
            for filename in os.listdir(directory):
                file_path = os.path.join(directory, filename)
                if os.path.isfile(file_path):
                    if is_binary_file(file_path):
                        print(f"Skipping binary file: {filename}")
                        continue
                    with open(file_path, 'r', encoding='utf-8') as file:
                        content = file.read()
                    output.write(f"{filename}:\n\n{content}\n\n\n")
        print(f"Content written to {output_file} successfully.")
    except Exception as e:
        print(f"An error occurred: {e}")

# Directory containing files
input_directory = "/Users/yaroslav/cryptoBot/"

# Output file
output_filename = "output.txt"

save_files_content_to_text(input_directory, output_filename)





